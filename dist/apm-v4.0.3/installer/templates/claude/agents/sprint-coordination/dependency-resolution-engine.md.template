# Dependency Resolution Engine Template
<!-- APM Migration Template - Real-Time Dependency Management for Parallel Streams -->
<!-- Template Version: {{MIGRATION_VERSION}} -->
<!-- Agent: {{AGENT_NAME}} -->
<!-- Compatible with: APM Framework 2.4+ -->

## üîó Real-Time Dependency Management System

This template provides the sophisticated dependency resolution engine that manages real-time dependencies between parallel development streams, ensuring seamless coordination and preventing blocking issues.

### üéØ Core Dependency Management Capabilities

**What This Engine Enables**:
- **Real-time dependency tracking** across {{MAX_PARALLEL_DEVELOPERS}} development streams
- **Proactive blocker identification** and resolution before impact
- **Intelligent dependency resolution** with {{DEPENDENCY_RESOLUTION_MODE}} strategies
- **Dynamic dependency graph updates** as stories progress
- **Automated escalation** for critical dependency issues

## üìä Dependency Classification System

### Dependency Types & Priorities
```bash
# Critical Dependencies (P0) - Block sprint completion
CRITICAL_DEPENDENCIES:
  - Story completion dependencies (Story A ‚Üí Story B)
  - Shared API contract dependencies
  - Database schema change dependencies
  - Integration endpoint dependencies
  Resolution SLA: {{CRITICAL_DEPENDENCY_SLA}} hours
```

```bash
# High Priority Dependencies (P1) - Impact stream efficiency
HIGH_PRIORITY_DEPENDENCIES:
  - Shared component dependencies
  - Configuration dependencies
  - Testing infrastructure dependencies
  - Documentation dependencies
  Resolution SLA: {{HIGH_DEPENDENCY_SLA}} hours
```

```bash
# Medium Priority Dependencies (P2) - Optimization opportunities
MEDIUM_PRIORITY_DEPENDENCIES:
  - Performance optimization dependencies
  - UI/UX consistency dependencies
  - Code style and convention dependencies
  - Non-critical integration dependencies
  Resolution SLA: {{MEDIUM_DEPENDENCY_SLA}} hours
```

```bash
# Low Priority Dependencies (P3) - Future sprint items
LOW_PRIORITY_DEPENDENCIES:
  - Enhancement dependencies
  - Refactoring dependencies
  - Nice-to-have feature dependencies
  - Documentation improvement dependencies
  Resolution SLA: {{LOW_DEPENDENCY_SLA}} hours
```

## üîÑ Dependency Resolution Process

### Phase 1: Dependency Discovery & Mapping
```bash
# Automatic dependency identification
def discover_dependencies(sprint_stories):
    analyze_story_acceptance_criteria()
    identify_shared_components()
    map_api_contract_requirements()
    detect_database_schema_changes()
    catalog_integration_endpoints()
    create_dependency_matrix()
```

**Discovery Tasks**:
1. **Story Analysis**: Parse acceptance criteria for external dependencies
2. **Component Mapping**: Identify shared libraries, utilities, and frameworks
3. **API Contract Analysis**: Map service interfaces and data contracts
4. **Database Impact Assessment**: Identify schema changes and data migrations
5. **Integration Point Cataloging**: Document external system dependencies

### Phase 2: Dependency Graph Construction
```bash
# Build comprehensive dependency graph
def build_dependency_graph():
    create_story_nodes()
    establish_dependency_edges()
    calculate_dependency_weights()
    identify_critical_paths()
    detect_circular_dependencies()
    optimize_parallel_execution_paths()
```

**Graph Construction Elements**:
- **Nodes**: Stories, components, APIs, databases, external systems
- **Edges**: Dependency relationships with weights and types
- **Critical Paths**: Longest dependency chains affecting sprint completion
- **Parallel Clusters**: Groups of stories that can execute simultaneously
- **Bottleneck Identification**: Dependencies that constrain overall velocity

### Phase 3: Real-Time Resolution Management
```bash
# Continuous dependency monitoring and resolution
def manage_dependency_resolution():
    monitor_dependency_status()
    detect_blocking_conditions()
    trigger_automated_resolution()
    escalate_critical_blockers()
    update_dependency_graph()
    optimize_stream_coordination()
```

## üéÆ Dependency Resolution Commands

### Core Resolution Commands
```bash
# Primary dependency management
/analyze-dependencies              # Discover and map all sprint dependencies
/resolve-dependency <dep-id>       # Resolve specific dependency
/escalate-blocker <dep-id>        # Escalate critical blocking dependency
/update-dependency-graph          # Refresh dependency relationships
/optimize-parallel-paths          # Optimize stories for parallel execution
```

### Monitoring & Tracking Commands
```bash
# Dependency status monitoring
/dependency-status               # Show all dependency statuses
/critical-path-analysis         # Analyze critical dependency paths
/blocker-report                 # Generate current blocker report
/dependency-health-check        # Validate dependency resolution health
/stream-dependency-matrix       # Show dependencies between streams
```

### Resolution Strategy Commands
```bash
# Advanced resolution strategies
/auto-resolve-dependencies      # Trigger automated resolution workflows
/coordinate-handoffs           # Coordinate dependency handoffs between streams
/parallel-resolution           # Resolve multiple dependencies in parallel
/dependency-workaround <dep-id> # Implement dependency workaround strategy
```

## üîß Resolution Strategy Framework

### Proactive Resolution Strategies
```bash
# Strategy 1: Predictive Resolution
PREDICTIVE_RESOLUTION:
  approach: "forecast_and_prevent"
  triggers:
    - Story progress milestones
    - Integration checkpoint approaches
    - Quality gate validations
  actions:
    - Pre-resolve anticipated dependencies
    - Coordinate early handoffs
    - Prepare fallback strategies
```

```bash
# Strategy 2: Parallel Resolution
PARALLEL_RESOLUTION:
  approach: "concurrent_resolution"
  triggers:
    - Multiple dependencies from same source
    - Independent resolution paths available
    - Stream capacity available for parallel work
  actions:
    - Launch parallel resolution tasks
    - Coordinate simultaneous handoffs
    - Aggregate resolution results
```

```bash
# Strategy 3: Workaround Implementation
WORKAROUND_IMPLEMENTATION:
  approach: "temporary_unblocking"
  triggers:
    - Dependency resolution exceeds SLA
    - Critical path impact detected
    - External dependency unavailable
  actions:
    - Implement temporary workarounds
    - Create mock implementations
    - Establish manual coordination processes
```

### Reactive Resolution Patterns
```bash
# Pattern 1: Escalation Chain
ESCALATION_CHAIN:
  levels:
    - Level 1: Automated resolution attempt
    - Level 2: Cross-stream coordination
    - Level 3: Scrum Master intervention
    - Level 4: Product Owner prioritization
    - Level 5: External stakeholder engagement
  escalation_criteria:
    - Resolution time exceeds SLA
    - Multiple streams blocked
    - Critical path impact
```

```bash
# Pattern 2: Emergency Unblocking
EMERGENCY_UNBLOCKING:
  triggers:
    - Sprint goal at risk
    - Multiple streams blocked simultaneously
    - External dependency failures
  actions:
    - Immediate workaround implementation
    - Emergency coordination sessions
    - Scope adjustment consultation
    - Risk mitigation strategies
```

## üìä Dependency Monitoring Dashboard

### Real-Time Dependency Status
```yaml
dependency_dashboard:
  critical_dependencies:
    total: {{CRITICAL_DEP_COUNT}}
    resolved: {{CRITICAL_DEP_RESOLVED}}
    blocked: {{CRITICAL_DEP_BLOCKED}}
    overdue: {{CRITICAL_DEP_OVERDUE}}
  
  high_priority_dependencies:
    total: {{HIGH_DEP_COUNT}}
    in_progress: {{HIGH_DEP_IN_PROGRESS}}
    pending: {{HIGH_DEP_PENDING}}
    
  stream_health:
    alpha_blocked: {{ALPHA_BLOCKED_COUNT}}
    beta_blocked: {{BETA_BLOCKED_COUNT}}
    gamma_integration_risk: {{GAMMA_RISK_LEVEL}}
    delta_testing_dependencies: {{DELTA_DEP_COUNT}}
```

### Dependency Resolution Metrics
```yaml
resolution_metrics:
  average_resolution_time:
    critical: "{{CRITICAL_AVG_RESOLUTION}} hours"
    high: "{{HIGH_AVG_RESOLUTION}} hours"
    medium: "{{MEDIUM_AVG_RESOLUTION}} hours"
    
  success_rates:
    automated_resolution: "{{AUTO_RESOLUTION_RATE}}%"
    manual_intervention: "{{MANUAL_INTERVENTION_RATE}}%"
    escalation_required: "{{ESCALATION_RATE}}%"
    
  impact_metrics:
    stories_unblocked: {{STORIES_UNBLOCKED}}
    streams_accelerated: {{STREAMS_ACCELERATED}}
    sprint_velocity_improvement: "{{VELOCITY_IMPROVEMENT}}%"
```

## ü§ñ Automated Resolution Workflows

### Workflow 1: Shared Component Resolution
```bash
# Automatically resolve shared component dependencies
def resolve_shared_component_dependency(component_id):
    identify_dependent_streams()
    coordinate_component_development()
    establish_interface_contracts()
    schedule_integration_windows()
    validate_compatibility()
    update_all_dependent_streams()
```

### Workflow 2: API Contract Resolution
```bash
# Resolve API contract dependencies automatically
def resolve_api_contract_dependency(api_contract):
    validate_contract_specifications()
    coordinate_provider_and_consumer_streams()
    implement_contract_stubs()
    schedule_integration_testing()
    monitor_contract_compliance()
```

### Workflow 3: Database Schema Resolution
```bash
# Handle database schema change dependencies
def resolve_database_dependency(schema_change):
    analyze_impact_across_streams()
    coordinate_migration_strategy()
    implement_backward_compatibility()
    schedule_deployment_windows()
    validate_data_integrity()
    update_dependent_services()
```

## üö® Critical Dependency Scenarios

### Scenario 1: Cross-Stream Blocking Dependency
```bash
# When one stream blocks multiple others
CROSS_STREAM_BLOCKING:
  detection:
    - Monitor dependency graph for bottlenecks
    - Identify single points of failure
    - Track cross-stream impact metrics
  
  resolution:
    - Immediate escalation to Integration Stream
    - Resource reallocation to unblock
    - Parallel workaround implementation
    - Communication to all affected streams
```

### Scenario 2: External Dependency Failure
```bash
# When external systems cause blocking
EXTERNAL_DEPENDENCY_FAILURE:
  detection:
    - Monitor external system health
    - Track SLA breaches from external providers
    - Identify communication failures
  
  resolution:
    - Activate fallback mechanisms
    - Implement mock services
    - Coordinate with external teams
    - Document impact and mitigation
```

### Scenario 3: Circular Dependency Detection
```bash
# When circular dependencies are discovered
CIRCULAR_DEPENDENCY_RESOLUTION:
  detection:
    - Graph analysis algorithms
    - Dependency cycle detection
    - Impact assessment on parallel streams
  
  resolution:
    - Break circular dependencies through redesign
    - Implement dependency inversion
    - Coordinate architecture changes
    - Update affected stories and streams
```

## üìã Dependency Resolution Checklist

### Daily Dependency Management
- [ ] Review overnight dependency status changes
- [ ] Validate critical path dependency health
- [ ] Check for new dependencies introduced by story progress
- [ ] Monitor external dependency system health
- [ ] Update dependency resolution metrics and dashboards

### Weekly Dependency Analysis
- [ ] Analyze dependency resolution patterns and trends
- [ ] Identify recurring dependency types and sources
- [ ] Optimize automated resolution workflows
- [ ] Review and update dependency SLAs
- [ ] Conduct dependency resolution retrospective

### Sprint-Level Dependency Planning
- [ ] Map all sprint dependencies before sprint start
- [ ] Establish dependency resolution ownership
- [ ] Create contingency plans for high-risk dependencies
- [ ] Set up monitoring and alerting for critical dependencies
- [ ] Document lessons learned for future sprint planning

## ‚öôÔ∏è Configuration Templates

### Dependency Resolution Engine Configuration
```yaml
dependency_engine:
  resolution_modes:
    proactive: {{PROACTIVE_RESOLUTION_ENABLED}}
    reactive: {{REACTIVE_RESOLUTION_ENABLED}}
    predictive: {{PREDICTIVE_RESOLUTION_ENABLED}}
  
  sla_thresholds:
    critical: {{CRITICAL_DEPENDENCY_SLA}}
    high: {{HIGH_DEPENDENCY_SLA}}
    medium: {{MEDIUM_DEPENDENCY_SLA}}
    low: {{LOW_DEPENDENCY_SLA}}
  
  escalation_settings:
    auto_escalation: {{AUTO_ESCALATION_ENABLED}}
    escalation_intervals: {{ESCALATION_INTERVALS}}
    max_escalation_levels: {{MAX_ESCALATION_LEVELS}}
```

### Monitoring Configuration
```yaml
dependency_monitoring:
  check_intervals:
    critical_dependencies: "{{CRITICAL_CHECK_INTERVAL}} minutes"
    high_dependencies: "{{HIGH_CHECK_INTERVAL}} minutes"
    all_dependencies: "{{ALL_CHECK_INTERVAL}} minutes"
  
  alerting:
    sla_breach_alerts: {{SLA_BREACH_ALERTS}}
    blocking_dependency_alerts: {{BLOCKING_ALERTS}}
    resolution_success_notifications: {{SUCCESS_NOTIFICATIONS}}
```

## üîç Advanced Dependency Analytics

### Dependency Pattern Analysis
```bash
# Analyze dependency patterns for optimization
def analyze_dependency_patterns():
    identify_common_dependency_types()
    measure_resolution_time_trends()
    detect_recurring_bottlenecks()
    optimize_dependency_prevention_strategies()
    improve_parallel_execution_opportunities()
```

### Predictive Dependency Management
```bash
# Use AI/ML for predictive dependency resolution
def predict_dependency_issues():
    analyze_historical_dependency_data()
    predict_likely_blocking_scenarios()
    recommend_proactive_resolution_strategies()
    optimize_stream_assignment_based_on_dependencies()
    prevent_dependency_conflicts_before_they_occur()
```

### Dependency Impact Modeling
```bash
# Model dependency impact on sprint success
def model_dependency_impact():
    calculate_dependency_criticality_scores()
    simulate_dependency_failure_scenarios()
    optimize_dependency_resolution_priorities()
    predict_sprint_completion_probability()
    recommend_risk_mitigation_strategies()
```

---

## üîÑ Template Migration & Environment Variables

### Core Configuration Variables
```bash
# Dependency management settings
{{MAX_PARALLEL_DEVELOPERS}}=4           # Maximum concurrent streams
{{DEPENDENCY_RESOLUTION_MODE}}=proactive # Resolution strategy
{{CRITICAL_DEPENDENCY_SLA}}=2           # Critical dependency SLA (hours)
{{HIGH_DEPENDENCY_SLA}}=4               # High priority SLA (hours)
{{MEDIUM_DEPENDENCY_SLA}}=8             # Medium priority SLA (hours)
{{LOW_DEPENDENCY_SLA}}=24               # Low priority SLA (hours)

# Monitoring and alerting
{{CRITICAL_CHECK_INTERVAL}}=15          # Critical check interval (minutes)
{{HIGH_CHECK_INTERVAL}}=30              # High priority check interval
{{ALL_CHECK_INTERVAL}}=60               # All dependencies check interval
{{AUTO_ESCALATION_ENABLED}}=true        # Enable automatic escalation
{{ESCALATION_INTERVALS}}=1,2,4          # Escalation intervals (hours)

# Resolution effectiveness thresholds
{{AUTO_RESOLUTION_RATE}}=85             # Target automated resolution rate %
{{MANUAL_INTERVENTION_RATE}}=12         # Expected manual intervention rate %
{{ESCALATION_RATE}}=3                   # Target escalation rate %
```

### Environment Integration
```bash
{{AP_ROOT}}                    # APM framework root directory
{{PROJECT_ROOT}}/project_docs               # Project documentation path
{{DEPENDENCY_DATA_PATH}}       # Dependency tracking data storage
{{RESOLUTION_LOG_PATH}}        # Resolution activity logs
{{ESCALATION_CONFIG_PATH}}     # Escalation configuration
```

This template enables sophisticated real-time dependency management that prevents blocking issues and maintains optimal parallel development velocity across all sprint streams.