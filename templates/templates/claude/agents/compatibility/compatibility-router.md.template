# Compatibility Router Template

**Version**: 1.0.0  
**Component**: Backward Compatibility Layer  
**Purpose**: Route parallel commands between native sub-agents and Task-based execution

## Overview

The Compatibility Router ensures seamless transition between Task-based and native sub-agent execution modes while maintaining backward compatibility for existing workflows.

## Router Architecture

```mermaid
graph TD
    A[User Command] --> B[Compatibility Router]
    B --> C{Mode Detection}
    C --> D[Check Native Support]
    C --> E[Check User Config]
    C --> F[Check Command Compatibility]
    
    D --> G{Native Available?}
    G -->|Yes| H[Native Sub-Agents]
    G -->|No| I[Task Tool]
    
    E --> J{User Preference}
    J -->|Native| H
    J -->|Task| I
    J -->|Auto| K[Auto Selection]
    
    K --> L{Performance Test}
    L -->|Native Better| H
    L -->|Task Better| I
    
    H --> M[Unified Result]
    I --> M
    M --> N[User Output]
```

## Mode Detection Logic

```yaml
mode_detection:
  priority:
    1: force_mode         # User explicitly sets mode
    2: command_config     # Per-command configuration
    3: global_default     # Global default setting
    4: auto_detection     # Smart detection based on context
  
  detection_criteria:
    native_available:
      - check: "Claude Code version >= 2.0"
      - check: "Sub-agent support enabled"
      - check: "Command has native implementation"
    
    performance_factors:
      - parallel_tasks: "> 3"
      - execution_time: "> 30s"
      - resource_usage: "high"
```

## Routing Implementation

### 1. Entry Point Detection

```typescript
interface CompatibilityRouter {
  route(command: ParallelCommand): ExecutionResult {
    // Step 1: Detect execution mode
    const mode = this.detectMode(command);
    
    // Step 2: Log routing decision
    this.logRouting(command, mode);
    
    // Step 3: Execute with appropriate method
    try {
      return mode === 'native' 
        ? this.executeNative(command)
        : this.executeTask(command);
    } catch (error) {
      return this.handleFallback(command, error);
    }
  }
}
```

### 2. Mode Detection Algorithm

```typescript
detectMode(command: ParallelCommand): ExecutionMode {
  // Check force mode
  if (command.options.mode) {
    return command.options.mode;
  }
  
  // Check command-specific config
  const commandConfig = this.config.commands[command.name];
  if (commandConfig?.mode) {
    return commandConfig.mode;
  }
  
  // Check global default
  if (this.config.execution.default_mode !== 'auto') {
    return this.config.execution.default_mode;
  }
  
  // Auto detection
  return this.autoDetect(command);
}
```

### 3. Auto Detection Logic

```typescript
autoDetect(command: ParallelCommand): ExecutionMode {
  // Check native availability
  if (!this.isNativeAvailable()) {
    return 'task';
  }
  
  // Check command compatibility
  if (!this.isCommandCompatible(command)) {
    return 'task';
  }
  
  // Performance-based selection
  const metrics = this.getPerformanceMetrics(command);
  if (metrics.expectedImprovement > 2.0) {
    return 'native';
  }
  
  return 'task';
}
```

## Fallback Mechanism

### Fallback Triggers

1. **Native Execution Failure**
   - Sub-agent initialization error
   - Communication timeout
   - Resource constraints

2. **Compatibility Issues**
   - Unsupported command features
   - Version mismatch
   - Missing dependencies

### Fallback Implementation

```typescript
handleFallback(command: ParallelCommand, error: Error): ExecutionResult {
  // Check if fallback is enabled
  if (!this.config.execution.fallback_enabled) {
    throw error;
  }
  
  // Log fallback event
  this.logFallback(command, error);
  
  // Notify user
  this.notifyFallback(command, error);
  
  // Execute with Task tool
  return this.executeTask(command);
}
```

## Execution Methods

### Native Sub-Agent Execution

```typescript
executeNative(command: ParallelCommand): ExecutionResult {
  const startTime = Date.now();
  
  // Initialize sub-agents
  const agents = this.initializeSubAgents(command);
  
  // Execute in parallel
  const results = await Promise.all(
    agents.map(agent => agent.execute())
  );
  
  // Track performance
  const executionTime = Date.now() - startTime;
  this.trackPerformance('native', command, executionTime);
  
  return this.formatResults(results);
}
```

### Task-Based Execution

```typescript
executeTask(command: ParallelCommand): ExecutionResult {
  const startTime = Date.now();
  
  // Convert to Task format
  const tasks = this.convertToTasks(command);
  
  // Execute with Task tool
  const results = await this.taskTool.execute(tasks);
  
  // Track performance
  const executionTime = Date.now() - startTime;
  this.trackPerformance('task', command, executionTime);
  
  return this.formatResults(results);
}
```

## Configuration Management

### Configuration Schema

```yaml
# .apm/config/parallel-execution.yaml
execution:
  default_mode: auto      # auto|native|task
  fallback_enabled: true
  show_performance: true
  deprecation_warnings: true
  performance_tracking: true
  
  # Auto-detection thresholds
  auto_detection:
    min_improvement_ratio: 2.0
    parallel_task_threshold: 3
    execution_time_threshold: 30000  # ms

# Per-command configuration
commands:
  parallel-sprint:
    mode: native
    fallback: true
    expected_improvement: 4.5
    
  parallel-qa-framework:
    mode: auto
    fallback: true
    expected_improvement: 4.2
    
  parallel-stories:
    mode: task
    fallback: false
    migration_ready: true
```

### Configuration Loading

```typescript
loadConfiguration(): CompatibilityConfig {
  const defaultConfig = this.getDefaultConfig();
  const userConfig = this.loadUserConfig();
  
  return this.mergeConfigs(defaultConfig, userConfig);
}
```

## Performance Tracking

### Metrics Collection

```typescript
interface PerformanceMetrics {
  command: string;
  mode: ExecutionMode;
  executionTime: number;
  taskCount: number;
  parallelization: number;
  resourceUsage: ResourceMetrics;
  timestamp: Date;
}
```

### Performance Comparison

```typescript
comparePerformance(command: string): PerformanceComparison {
  const nativeMetrics = this.getMetrics(command, 'native');
  const taskMetrics = this.getMetrics(command, 'task');
  
  return {
    improvement: nativeMetrics.avgTime / taskMetrics.avgTime,
    nativeAvg: nativeMetrics.avgTime,
    taskAvg: taskMetrics.avgTime,
    recommendation: this.getRecommendation(nativeMetrics, taskMetrics)
  };
}
```

## User Notifications

### Mode Indication

```typescript
notifyExecutionMode(command: string, mode: ExecutionMode): void {
  if (!this.config.execution.show_performance) return;
  
  const performance = this.getPerformanceData(command, mode);
  
  console.log(`
    ðŸš€ Executing with ${mode} mode
    Expected performance: ${performance.expected}
    ${mode === 'task' ? 'To use native mode: add --mode=native' : ''}
  `);
}
```

### Fallback Notification

```typescript
notifyFallback(command: ParallelCommand, error: Error): void {
  console.log(`
    âš ï¸ Native execution encountered an issue
    Reason: ${error.message}
    
    Falling back to Task-based execution...
    
    This may affect performance but functionality is preserved.
  `);
}
```

## Migration Support

### Migration Status Tracking

```typescript
interface MigrationStatus {
  command: string;
  totalExecutions: number;
  nativeExecutions: number;
  taskExecutions: number;
  averageImprovement: number;
  migrationReady: boolean;
}
```

### Migration Dashboard

```typescript
generateMigrationDashboard(): string {
  const statuses = this.getAllMigrationStatuses();
  
  return `
ðŸ“Š Parallel Command Migration Status
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Command               Mode    Migrations  Avg Improvement
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
${statuses.map(s => this.formatStatus(s)).join('\n')}

Overall Migration: ${this.calculateOverallProgress()}% complete
${this.getMigrationRecommendations()}
  `;
}
```

## Error Handling

### Error Categories

1. **Initialization Errors**
   - Missing dependencies
   - Version incompatibility
   - Resource constraints

2. **Execution Errors**
   - Sub-agent failures
   - Communication timeouts
   - Invalid parameters

3. **Fallback Errors**
   - Task tool unavailable
   - Fallback disabled
   - Recursive failures

### Error Recovery

```typescript
handleError(error: Error, context: ExecutionContext): Recovery {
  const category = this.categorizeError(error);
  
  switch (category) {
    case 'initialization':
      return this.handleInitError(error, context);
    case 'execution':
      return this.handleExecError(error, context);
    case 'fallback':
      return this.handleFallbackError(error, context);
    default:
      throw error;
  }
}
```

## Testing Support

### Compatibility Testing

```typescript
testCompatibility(command: ParallelCommand): CompatibilityTest {
  const nativeResult = this.executeNative(command);
  const taskResult = this.executeTask(command);
  
  return {
    consistent: this.compareResults(nativeResult, taskResult),
    performanceGain: this.calculateGain(nativeResult, taskResult),
    errors: this.compareErrors(nativeResult, taskResult)
  };
}
```

### Mode Forcing for Testing

```bash
# Force native mode
/parallel-sprint --mode=native

# Force task mode
/parallel-sprint --mode=task

# Compare both modes
/parallel-sprint --mode=compare
```

## Integration Points

### With Native Sub-Agents

```typescript
interface NativeIntegration {
  checkAvailability(): boolean;
  initializeAgents(config: AgentConfig[]): Agent[];
  executeParallel(agents: Agent[]): Promise<Result[]>;
  cleanupAgents(agents: Agent[]): void;
}
```

### With Task Tool

```typescript
interface TaskIntegration {
  convertToTasks(command: ParallelCommand): Task[];
  executeTasks(tasks: Task[]): Promise<Result[]>;
  formatTaskResults(results: Result[]): ExecutionResult;
}
```

## Usage Examples

### Basic Usage

```bash
# Auto mode (default)
/parallel-sprint

# Force native mode
/parallel-sprint --mode=native

# Force task mode
/parallel-sprint --mode=task

# Show performance comparison
/parallel-sprint --show-performance
```

### Configuration Examples

```yaml
# Enable native by default
execution:
  default_mode: native
  
# Disable fallback
execution:
  fallback_enabled: false
  
# Per-command overrides
commands:
  parallel-sprint:
    mode: native
    fallback: true
```

### Migration Examples

```bash
# Check migration status
/migration-status

# Test compatibility
/test-compatibility parallel-sprint

# Migrate specific command
/migrate-command parallel-sprint
```

## Summary

The Compatibility Router provides:
- Seamless transition between execution modes
- Intelligent mode selection
- Robust fallback mechanisms
- Performance tracking and comparison
- Migration support tools
- Full backward compatibility

This ensures users can adopt native sub-agents at their own pace while maintaining existing workflows.